spec is "1.0"
record "Job":
  field "job_id" is text must be present
  field "name" is text must be present
  field "status" is text must be present
  field "failure_class" is text must be present
  field "retry_count" is number must be present
  field "rollback_status" is text must be present
  field "expected_outcome" is text must be present
  field "actual_outcome" is text must be present
record "ExecutionEvent":
  field "job_id" is text must be present
  field "order" is number must be present
  field "event_type" is text must be present
  field "reason" is text must be present
  field "detail" is json must be present
record "OpsSummary":
  field "name" is text must be present
  field "health" is json must be present
  field "drift" is json must be present
  field "cost" is json must be present
  field "job_count" is number must be present
record "ExplainEntry":
  field "stage" is text must be present
  field "detail" is json must be present
flow "queue_job": requires true
  let job_key is ""
  let has_job is false
  try:
    set job_key is input.job_id
    set has_job is true
  with catch err:
    set has_job is false
  if has_job is false or job_key is "":
    return map:
      "status" is "invalid_job"
  let job_name is job_key
  try:
    set job_name is input.name
  with catch err:
    set job_name is job_key
  let expected_outcome is ""
  try:
    set expected_outcome is input.expected_outcome
  with catch err:
    set expected_outcome is ""
  find "Job" where job_id is job_key
  let job_count is list length of job_results
  let has_existing is job_count is greater than 0
  let previous_status is "none"
  let retry_count is 0
  let failure_code is ""
  let rollback_status is "none"
  let actual_outcome is ""
  if has_existing:
    let last_index is job_count - 1
    let existing_job is list get job_results at last_index
    set previous_status is existing_job.status
    set retry_count is existing_job.retry_count
    set failure_code is existing_job.failure_class
    set rollback_status is existing_job.rollback_status
    set actual_outcome is existing_job.actual_outcome
  if has_existing:
    update "Job" where job_id is job_key set:
      name is job_name
      status is "queued"
      failure_class is failure_code
      retry_count is retry_count
      rollback_status is rollback_status
      expected_outcome is expected_outcome
      actual_outcome is actual_outcome
  else:
    set state.job with:
      job_id is job_key
      name is job_name
      status is "queued"
      failure_class is ""
      retry_count is 0
      rollback_status is "none"
      expected_outcome is expected_outcome
      actual_outcome is ""
    create "Job" with state.job as job_record
  find "ExecutionEvent" where job_id is job_key
  let event_count is list length of executionevent_results
  let decision_order is event_count + 1
  set state.event with:
    job_id is job_key
    order is decision_order
    event_type is "decision"
    reason is "queue"
    detail is map:
      "previous" is previous_status
      "next" is "queued"
      "inputs" is map:
        "job_id" is job_key
        "name" is job_name
  create "ExecutionEvent" with state.event as event
  set state.explain_entry with:
    stage is "transition"
    detail is map:
      "job_id" is job_key
      "previous" is previous_status
      "next" is "queued"
      "reason" is "queue"
      "event_order" is decision_order
      "artifact_ids" is list:
        job_key
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "queued"
    "job_id" is job_key
flow "advance_job": requires true
  let job_key is ""
  let has_job is false
  try:
    set job_key is input.job_id
    set has_job is true
  with catch err:
    set has_job is false
  if has_job is false or job_key is "":
    return map:
      "status" is "invalid_job"
  let next_state is ""
  try:
    set next_state is input.next_state
  with catch err:
    set next_state is ""
  let state_valid is next_state is one of "running", "blocked", "done"
  if state_valid is false:
    return map:
      "status" is "invalid_state"
      "job_id" is job_key
  find "Job" where job_id is job_key
  let job_count is list length of job_results
  if job_count is 0:
    return map:
      "status" is "missing_job"
  let last_index is job_count - 1
  let existing_job is list get job_results at last_index
  let previous_status is existing_job.status
  let reason is ""
  try:
    set reason is input.reason
  with catch err:
    set reason is ""
  if reason is "":
    set reason is next_state
  let failure_code is ""
  try:
    set failure_code is input.failure_class
  with catch err:
    set failure_code is ""
  let class_valid is failure_code is one of "input", "policy", "dependency", "internal"
  let needs_default_class is false
  if next_state is "blocked":
    if class_valid is false or failure_code is "":
      set needs_default_class is true
  if needs_default_class:
    set failure_code is "internal"
  let outcome_value is ""
  try:
    set outcome_value is input.actual_outcome
  with catch err:
    set outcome_value is ""
  if next_state is "done" and outcome_value is "":
    set outcome_value is "complete"
  if next_state is "blocked":
    update "Job" where job_id is job_key set:
      status is "blocked"
      failure_class is failure_code
  if next_state is "running":
    update "Job" where job_id is job_key set:
      status is "running"
  if next_state is "done":
    update "Job" where job_id is job_key set:
      status is "done"
      actual_outcome is outcome_value
  find "ExecutionEvent" where job_id is job_key
  let event_count is list length of executionevent_results
  let decision_order is event_count + 1
  set state.event with:
    job_id is job_key
    order is decision_order
    event_type is "decision"
    reason is reason
    detail is map:
      "previous" is previous_status
      "next" is next_state
      "failure_class" is failure_code
      "result" is outcome_value
  create "ExecutionEvent" with state.event as event
  set state.explain_entry with:
    stage is "transition"
    detail is map:
      "job_id" is job_key
      "previous" is previous_status
      "next" is next_state
      "reason" is reason
      "event_order" is decision_order
      "artifact_ids" is list:
        job_key
  create "ExplainEntry" with state.explain_entry as explain
  if next_state is "blocked":
    set state.explain_entry with:
      stage is "failure"
      detail is map:
        "job_id" is job_key
        "classification" is failure_code
        "event_order" is decision_order
    create "ExplainEntry" with state.explain_entry as explain
  if next_state is "done":
    set state.explain_entry with:
      stage is "outcome"
      detail is map:
        "job_id" is job_key
        "status" is "done"
        "result" is outcome_value
        "event_order" is decision_order
    create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is next_state
    "job_id" is job_key
flow "retry_job": requires true
  let job_key is ""
  let has_job is false
  try:
    set job_key is input.job_id
    set has_job is true
  with catch err:
    set has_job is false
  if has_job is false or job_key is "":
    return map:
      "status" is "invalid_job"
  find "Job" where job_id is job_key
  let job_count is list length of job_results
  if job_count is 0:
    return map:
      "status" is "missing_job"
  let last_index is job_count - 1
  let existing_job is list get job_results at last_index
  let previous_status is existing_job.status
  let retry_count is existing_job.retry_count
  let max_retries is 2
  let retry_limit is max_retries - 1
  if retry_count is greater than retry_limit:
    set state.explain_entry with:
      stage is "retry_denied"
      detail is map:
        "job_id" is job_key
        "attempt" is retry_count + 1
        "reason" is "limit"
    create "ExplainEntry" with state.explain_entry as explain
    return map:
      "status" is "retry_limit"
      "job_id" is job_key
  let reason is ""
  try:
    set reason is input.reason
  with catch err:
    set reason is ""
  if reason is "":
    set reason is "retry"
  let next_retry is retry_count + 1
  update "Job" where job_id is job_key set:
    status is "queued"
    retry_count is next_retry
  find "ExecutionEvent" where job_id is job_key
  let event_count is list length of executionevent_results
  let event_order is event_count + 1
  set state.event with:
    job_id is job_key
    order is event_order
    event_type is "retry"
    reason is reason
    detail is map:
      "attempt" is next_retry
      "previous" is previous_status
      "next" is "queued"
  create "ExecutionEvent" with state.event as event
  set state.explain_entry with:
    stage is "retry"
    detail is map:
      "job_id" is job_key
      "attempt" is next_retry
      "reason" is reason
      "event_order" is event_order
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "queued"
    "job_id" is job_key
    "attempt" is next_retry
flow "rollback_job": requires true
  let job_key is ""
  let has_job is false
  try:
    set job_key is input.job_id
    set has_job is true
  with catch err:
    set has_job is false
  if has_job is false or job_key is "":
    return map:
      "status" is "invalid_job"
  find "Job" where job_id is job_key
  let job_count is list length of job_results
  if job_count is 0:
    return map:
      "status" is "missing_job"
  let last_index is job_count - 1
  let existing_job is list get job_results at last_index
  let previous_status is existing_job.status
  let reason is ""
  try:
    set reason is input.reason
  with catch err:
    set reason is ""
  if reason is "":
    set reason is "rollback"
  let artifacts is list:
  try:
    set artifacts is input.artifacts
  with catch err:
    set artifacts is list:
  update "Job" where job_id is job_key set:
    status is "blocked"
    rollback_status is "rolled_back"
  find "ExecutionEvent" where job_id is job_key
  let event_count is list length of executionevent_results
  let event_order is event_count + 1
  set state.event with:
    job_id is job_key
    order is event_order
    event_type is "rollback"
    reason is reason
    detail is map:
      "previous" is previous_status
      "next" is "blocked"
      "artifacts" is artifacts
  create "ExecutionEvent" with state.event as event
  set state.explain_entry with:
    stage is "rollback"
    detail is map:
      "job_id" is job_key
      "reason" is reason
      "artifacts" is artifacts
      "event_order" is event_order
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "blocked"
    "job_id" is job_key
flow "narrative_for_job": requires true
  let job_key is ""
  let has_job is false
  try:
    set job_key is input.job_id
    set has_job is true
  with catch err:
    set has_job is false
  if has_job is false or job_key is "":
    return map:
      "status" is "invalid_job"
  find "ExecutionEvent" where job_id is job_key
  return map:
    "status" is "ok"
    "job_id" is job_key
    "events" is executionevent_results
flow "summarize_operations": requires true
  find "Job" where true
  let total_jobs is list length of job_results
  let queued_jobs is filter job_results with item as element:
    element.status is "queued"
  let running_jobs is filter job_results with item as element:
    element.status is "running"
  let blocked_jobs is filter job_results with item as element:
    element.status is "blocked"
  let done_jobs is filter job_results with item as element:
    element.status is "done"
  let blocked_input is filter blocked_jobs with item as element:
    element.failure_class is "input"
  let blocked_policy is filter blocked_jobs with item as element:
    element.failure_class is "policy"
  let blocked_dependency is filter blocked_jobs with item as element:
    element.failure_class is "dependency"
  let blocked_internal is filter blocked_jobs with item as element:
    element.failure_class is "internal"
  let ordered is list:
  for each element in queued_jobs:
    set ordered is list append ordered with element
  for each element in running_jobs:
    set ordered is list append ordered with element
  for each element in blocked_jobs:
    set ordered is list append ordered with element
  for each element in done_jobs:
    set ordered is list append ordered with element
  let health is map:
    "total" is total_jobs
    "queued" is list length of queued_jobs
    "running" is list length of running_jobs
    "blocked" is list length of blocked_jobs
    "done" is list length of done_jobs
    "blocked_by_class" is map:
      "input" is list length of blocked_input
      "policy" is list length of blocked_policy
      "dependency" is list length of blocked_dependency
      "internal" is list length of blocked_internal
  let drift_jobs is filter job_results with item as element:
    element.expected_outcome is not "" and element.actual_outcome is not ""
  let drift_count is list length of drift_jobs
  let drift_changed is filter drift_jobs with item as element:
    element.expected_outcome is not equal to element.actual_outcome
  let changed_count is list length of drift_changed
  let stable_count is drift_count - changed_count
  let drift_status is "not_available"
  if drift_count is greater than 0:
    set drift_status is "available"
  let drift is map:
    "status" is drift_status
    "observed" is drift_count
    "changed" is changed_count
    "stable" is stable_count
  let cost is map:
    "status" is "not_available"
    "units" is 0
    "calls" is 0
  find "OpsSummary" where name is "current"
  let summary_count is list length of opssummary_results
  if summary_count is greater than 0:
    update "OpsSummary" where name is "current" set:
      health is health
      drift is drift
      cost is cost
      job_count is total_jobs
  else:
    set state.summary with:
      name is "current"
      health is health
      drift is drift
      cost is cost
      job_count is total_jobs
    create "OpsSummary" with state.summary as summary
  set state.explain_entry with:
    stage is "summary"
    detail is map:
      "job_count" is total_jobs
      "health" is health
      "drift" is drift
      "cost" is cost
      "order" is list:
        "queued"
        "running"
        "blocked"
        "done"
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "ok"
    "job_count" is total_jobs
    "health" is health
    "drift" is drift
    "cost" is cost
    "jobs" is ordered
page "Operations":
  purpose is "Deterministic job lifecycle, narratives, and operational summaries."
  title is "Operations"
  text is "Inspect jobs, execution narratives, and operational summaries."
  section "Jobs":
    table is "Job":
      columns:
        include job_id
        include name
        include status
        include failure_class
        include retry_count
        include rollback_status
      pagination:
        page_size is 10
  section "Execution Narrative":
    table is "ExecutionEvent":
      columns:
        include job_id
        include order
        include event_type
        include reason
      pagination:
        page_size is 10
  section "Summary":
    table is "OpsSummary":
      columns:
        include name
        include job_count
        include health
        include drift
        include cost
      pagination:
        page_size is 5
  section "Explain":
    table is "ExplainEntry":
      columns:
        include stage
        include detail
      pagination:
        page_size is 10
