spec is "1.0"
capabilities:
  uploads
policy
  allow ingestion.run
  allow ingestion.review
  require ingestion.override with ingestion.override
  require ingestion.skip with ingestion.skip
  require retrieval.include_warn with retrieval.include_warn
  require upload.replace with upload.replace
record "Case":
  field "case_id" is text must be present
  field "title" is text must be present
  field "summary" is text must be present
  field "status" is text must be present
  field "route" is text must be present
  field "policy_code" is text must be present
record "CaseArchive":
  field "case_id" is text must be present
  field "title" is text must be present
  field "summary" is text must be present
  field "outcome" is text must be present
  field "evidence_ids" is json must be present
record "ExplainEntry":
  field "stage" is text must be present
  field "detail" is json must be present
flow "receive_case": requires true
  let case_key is ""
  let has_case is false
  try:
    set case_key is input.case_id
    set has_case is true
  with catch err:
    set has_case is false
  if has_case is false or case_key is "":
    try:
      set case_key is input.upload_id
      set has_case is true
    with catch err:
      set has_case is false
  if has_case is false or case_key is "":
    return map:
      "status" is "invalid_case"
  let case_title is ""
  let case_summary is ""
  let route is ""
  let policy_code is ""
  try:
    set case_title is input.title
  with catch err:
    set case_title is ""
  try:
    set case_summary is input.summary
  with catch err:
    set case_summary is ""
  try:
    set route is input.route
  with catch err:
    set route is ""
  try:
    set policy_code is input.policy_code
  with catch err:
    set policy_code is ""
  if case_title is "":
    set case_title is case_key
  if case_summary is "":
    set case_summary is case_title
  if route is "":
    set route is "both"
  let route_valid is route is one of "knowledge", "cases", "both"
  if route_valid is false:
    set route is "both"
  find "Case" where case_id is case_key
  let case_count is list length of case_results
  let has_existing is case_count is greater than 0
  let previous_status is "none"
  if has_existing:
    let last_index is case_count - 1
    let existing_case is list get case_results at last_index
    set previous_status is existing_case.status
  if has_existing:
    update "Case" where case_id is case_key set:
      "title" is case_title
      summary is case_summary
      status is "received"
      route is route
      policy_code is policy_code
  else:
    set state.case with:
      case_id is case_key
      title is case_title
      summary is case_summary
      status is "received"
      route is route
      policy_code is policy_code
    create "Case" with state.case as case
  set state.explain_entry with:
    stage is "transition"
    detail is map:
      "case_id" is case_key
      "previous" is previous_status
      "next" is "received"
      "reason" is "intake"
      "evidence_ids" is list:
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "received"
    "case_id" is case_key
flow "understand_case": requires true
  let case_key is ""
  let has_case is false
  try:
    set case_key is input.case_id
    set has_case is true
  with catch err:
    set has_case is false
  if has_case is false or case_key is "":
    return map:
      "status" is "invalid_case"
  find "Case" where case_id is case_key
  let case_count is list length of case_results
  if case_count is 0:
    return map:
      "status" is "missing_case"
  let last_index is case_count - 1
  let current_case is list get case_results at last_index
  let previous_status is current_case.status
  let query is ""
  try:
    set query is input.query
  with catch err:
    set query is ""
  if query is "":
    set query is current_case.summary
  let route is current_case.route
  try:
    set route is input.route
  with catch err:
    set route is current_case.route
  if route is "" or route is null:
    set route is "both"
  let route_valid is route is one of "knowledge", "cases", "both"
  if route_valid is false:
    set route is "both"
  update "Case" where case_id is case_key set:
    status is "understood"
    route is route
  set state.explain_entry with:
    stage is "transition"
    detail is map:
      "case_id" is case_key
      "previous" is previous_status
      "next" is "understood"
      "reason" is "retrieval"
      "evidence_ids" is list:
  create "ExplainEntry" with state.explain_entry as explain
  let limit_knowledge is list length of list: 1, 1, 1, 1
  let limit_cases is list length of list: 1, 1, 1
  let use_knowledge is route is "knowledge" or route is "both"
  let use_cases is route is "cases" or route is "both"
  let knowledge_report is map:
    "query" is ""
    "results" is list:
  if use_knowledge:
    let out is call pipeline "retrieval":
      input:
        query is query
        limit is limit_knowledge
      output:
        report
    set knowledge_report is out.report
  let case_ingestion is map:
    "default" is "block"
  let case_index is map:
    "chunks" is list:
  try:
    set case_ingestion is state.case_ingestion
    set case_index is state.case_index
  with catch err:
    set case_ingestion is map:
      "default" is "block"
    set case_index is map:
      "chunks" is list:
  let case_report is map:
    "query" is ""
    "results" is list:
  if use_cases:
    let out is call pipeline "retrieval":
      input:
        query is query
        limit is limit_cases
        ingestion is case_ingestion
        index is case_index
      output:
        report
    set case_report is out.report
  let knowledge_results is knowledge_report.results
  let case_results is case_report.results
  let merged_results is list:
  if use_knowledge:
    for each result in knowledge_results:
      let result_entry is map:
        "source_type" is "knowledge"
        "upload_id" is result.upload_id
        "chunk_id" is result.chunk_id
        "quality" is result.quality
        "text" is result.text
      set merged_results is list append merged_results with result_entry
  if use_cases:
    for each result in case_results:
      let result_entry is map:
        "source_type" is "case"
        "upload_id" is result.upload_id
        "chunk_id" is result.chunk_id
        "quality" is result.quality
        "text" is result.text
      set merged_results is list append merged_results with result_entry
  let result_count is list length of merged_results
  let total_limit is 0
  if use_knowledge:
    set total_limit is total_limit + limit_knowledge
  if use_cases:
    set total_limit is total_limit + limit_cases
  let coverage is 0
  if total_limit is greater than 0:
    set coverage is result_count / total_limit
  let top_text is ""
  if result_count is greater than 0:
    let first_result is list get merged_results at 0
    set top_text is first_result.text
  let citations is list:
  let evidence_ids is list:
  for each result in merged_results:
    set evidence_ids is list append evidence_ids with result.chunk_id
    let citation is map:
      "title" is result.upload_id
      "source_type" is result.source_type
      "source_id" is result.chunk_id
      "snippet" is result.text
    set citations is list append citations with citation
  set state.case_citations is citations
  set state.last_retrieval with:
    case_id is case_key
    result_count is result_count
    coverage is coverage
    evidence_ids is evidence_ids
    top_text is top_text
  set state.explain_entry with:
    stage is "routing"
    detail is map:
      "case_id" is case_key
      "route" is route
      "reason" is route
  create "ExplainEntry" with state.explain_entry as explain
  set state.explain_entry with:
    stage is "retrieval"
    detail is map:
      "case_id" is case_key
      "raw_query" is query
      "result_count" is result_count
      "coverage" is coverage
      "evidence_ids" is evidence_ids
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "understood"
    "case_id" is case_key
    "result_count" is result_count
flow "resolve_case": requires true
  let case_key is ""
  let has_case is false
  try:
    set case_key is input.case_id
    set has_case is true
  with catch err:
    set has_case is false
  if has_case is false or case_key is "":
    return map:
      "status" is "invalid_case"
  find "Case" where case_id is case_key
  let case_count is list length of case_results
  if case_count is 0:
    return map:
      "status" is "missing_case"
  let last_index is case_count - 1
  let current_case is list get case_results at last_index
  let previous_status is current_case.status
  let policy_code is current_case.policy_code
  let has_retrieval is false
  let retrieval is map:
    "case_id" is ""
  try:
    set retrieval is state.last_retrieval
    set has_retrieval is true
  with catch err:
    set has_retrieval is false
  if has_retrieval is false or retrieval.case_id is not case_key:
    return map:
      "status" is "missing_retrieval"
  let result_count is retrieval.result_count
  let coverage is retrieval.coverage
  let evidence_ids is retrieval.evidence_ids
  let top_text is retrieval.top_text
  let reason_code is ""
  if policy_code is one of "restricted", "sensitive", "regulated":
    set reason_code is "policy"
  if reason_code is "" and result_count is 0:
    set reason_code is "no_sources"
  let threshold is 1 / 4
  if reason_code is "" and coverage is less than threshold:
    set reason_code is "low_coverage"
  if reason_code is not "":
    update "Case" where case_id is case_key set:
      status is "escalated"
    set state.explain_entry with:
      stage is "transition"
      detail is map:
        "case_id" is case_key
        "previous" is previous_status
        "next" is "escalated"
        "reason" is reason_code
        "evidence_ids" is evidence_ids
    create "ExplainEntry" with state.explain_entry as explain
    set state.explain_entry with:
      stage is "outcome"
      detail is map:
        "case_id" is case_key
        "status" is "escalated"
        "coverage" is coverage
        "confidence" is 0
        "source_count" is result_count
    create "ExplainEntry" with state.explain_entry as explain
    return map:
      "status" is "escalated"
      "case_id" is case_key
  let response is top_text
  if response is "":
    set response is "No answer available."
  update "Case" where case_id is case_key set:
    status is "resolved"
  set state.explain_entry with:
    stage is "transition"
    detail is map:
      "case_id" is case_key
      "previous" is previous_status
      "next" is "resolved"
      "reason" is "evidence"
      "evidence_ids" is evidence_ids
  create "ExplainEntry" with state.explain_entry as explain
  find "CaseArchive" where case_id is case_key
  let archive_count is list length of casearchive_results
  let has_archive is archive_count is greater than 0
  if has_archive:
    update "CaseArchive" where case_id is case_key set:
      "title" is current_case.title
      summary is current_case.summary
      outcome is response
      evidence_ids is evidence_ids
  else:
    set state.case_archive with:
      case_id is case_key
      title is current_case.title
      summary is current_case.summary
      outcome is response
      evidence_ids is evidence_ids
    create "CaseArchive" with state.case_archive as archive
  let archive_text is current_case.summary
  let chunk_id is case_key
  let case_index is map:
    "chunks" is list:
  let case_chunks is list:
  try:
    set case_index is state.case_index
    set case_chunks is case_index.chunks
  with catch err:
    set case_index is map:
      "chunks" is list:
    set case_chunks is list:
  let kept_chunks is filter case_chunks with item as chunk:
    chunk.upload_id is not equal to case_key
  let new_chunk is map:
    "upload_id" is case_key
    "document_id" is case_key
    "source_name" is case_key
    "page_number" is 1
    "chunk_index" is 0
    "ingestion_phase" is "deep"
    "chunk_id" is chunk_id
    "order" is 0
    "text" is archive_text
  let updated_chunks is list append kept_chunks with new_chunk
  let updated_index is map set case_index key "chunks" value updated_chunks
  set state.case_index is updated_index
  let case_ingestion is map:
    "default" is "block"
  try:
    set case_ingestion is state.case_ingestion
  with catch err:
    set case_ingestion is map:
      "default" is "block"
  let ingest_report is map:
    "status" is "pass"
    "reasons" is list:
  let updated_ingestion is map set case_ingestion key case_key value ingest_report
  set state.case_ingestion is updated_ingestion
  set state.explain_entry with:
    stage is "learning"
    detail is map:
      "case_id" is case_key
      "chunk_id" is chunk_id
      "index_updated" is true
  create "ExplainEntry" with state.explain_entry as explain
  set state.explain_entry with:
    stage is "outcome"
    detail is map:
      "case_id" is case_key
      "status" is "resolved"
      "coverage" is coverage
      "confidence" is coverage
      "source_count" is result_count
      "evidence_ids" is evidence_ids
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "resolved"
    "case_id" is case_key
flow "remove_case_archive": requires true
  let case_key is ""
  let has_case is false
  try:
    set case_key is input.case_id
    set has_case is true
  with catch err:
    set has_case is false
  if has_case is false or case_key is "":
    return map:
      "status" is "invalid_case"
  find "CaseArchive" where case_id is case_key
  let archive_count is list length of casearchive_results
  if archive_count is 0:
    return map:
      "status" is "missing_archive"
  let case_index is map:
    "chunks" is list:
  let case_chunks is list:
  try:
    set case_index is state.case_index
    set case_chunks is case_index.chunks
  with catch err:
    set case_index is map:
      "chunks" is list:
    set case_chunks is list:
  let kept_chunks is filter case_chunks with item as chunk:
    chunk.upload_id is not equal to case_key
  let updated_index is map set case_index key "chunks" value kept_chunks
  set state.case_index is updated_index
  let case_ingestion is map:
    "default" is "block"
  try:
    set case_ingestion is state.case_ingestion
  with catch err:
    set case_ingestion is map:
      "default" is "block"
  let ingest_report is map:
    "status" is "block"
    "reasons" is list:
      "removed"
  let updated_ingestion is map set case_ingestion key case_key value ingest_report
  set state.case_ingestion is updated_ingestion
  delete "CaseArchive" where case_id is case_key
  set state.explain_entry with:
    stage is "archive_remove"
    detail is map:
      "case_id" is case_key
      "index_updated" is true
  create "ExplainEntry" with state.explain_entry as explain
  return map:
    "status" is "removed"
    "case_id" is case_key
page "Support":
  purpose is "Deterministic case intake, retrieval, and resolution."
  title is "Support Workflow"
  text is "Handle cases with explicit lifecycle and auditable routing."
  section "Cases":
    table is "Case":
      columns:
        include case_id
        include `title`
        include status
        include route
        include policy_code
      pagination:
        page_size is 10
  section "Explain":
    table is "ExplainEntry":
      columns:
        include stage
        include detail
      pagination:
        page_size is 10

